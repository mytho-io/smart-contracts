MeritManager
- это контракт должен регистрировать тотем, когда заканчивается sale period. 
- Мерит будет начисляться менеджером через функцию creditMerit. 
- Вестинг будет постепенно начислять токены MYTHO на баланс контракта MeritManager. 
- Должна быть возможность добавить адрес тотема в блэклист и если тотем в нем, он не может получать мерит поинты. 
- Работа протокола будет поделена на периоды, каждый из которых равен 30 дней, они будут считаться в контракте MeritManager, текущий период возвращается в currentPeriod. 
- также последняя четверть периода называется mythus, это должно возвращаться в функции isMythus. 
- Каждый пользователь, у кого есть какое-то количество тотем токенов, может 1 раз в mythus период вызвать boostTotem и увеличить количество мерит на балансе тотема на переменную oneTotemBoost, которая может быть изменена менеджером. Если пользователь уже проголосовал за 1 тотем, то за другой тотем в текущем периоде он проголосовать уже не может. 
- Когда мерит распределяется любым способом во время периода Mythus, то он имеет мультипликатор 1.5, он тоже должен быть в виде переменной, которую можно поменять. 
- Также При вызове пользователями totemBoost должна взиматься плата в нативных токенах, размер которой также задается в переменной. 
- И в конце месяца MYTHO распределяется между сообществами, пропорционально накопленным очкам Merit. Для того чттобы склеймить накопленные MYTHO тотем может вызвать для этого отдельную фукнцию в MeritManager.

MYTHO
Назначение: Создание токена MYTHO Government Token с общей эмиссией 1 миллиард токенов и их распределением между различными категориями (инсентивы, команда, казна, AMM, airdrop).
Основные характеристики:
Общий запас: 1 миллиард токенов (18 decimals).
Распределение:
50% (500M) — инсентивы для Totem (4 года с ежегодным выпуском: 175M, 125M, 100M, 50M).
20% (200M) — команда (vesting 2 года).
18% (180M) — казна (без vesting).
7% (70M) — AMM-инсентивы (vesting 2 года).
5% (50M) — airdrop (без vesting).
Функционал:
Конструктор: Разворачивает токен, создает vesting-кошельки и распределяет токены.
burn: Позволяет владельцу сжигать свои токены.
mint (тестовая): Минтит токены (вероятно, для тестирования).
Ограничения:
Нулевые адреса для получателей запрещены.
Сжигание токенов доступно только владельцу.
Особенности:
Использует VestingWallet для постепенного выпуска токенов (1–4 года).
Не обновляемый контракт, что фиксирует логику распределения.
Контракт предназначен для управления токеном MYTHO с акцентом на долгосрочное распределение через vesting и немедленный доступ для казны и airdrop. Тестовая функция mint указывает на возможность доработки для разработчиков.

Totem
Назначение: Хранение и управление токенами TotemToken и MYTH, а также предоставление данных о резервах и хэше данных.
Основные характеристики:
Инициализируется с адресами токенов TotemToken и MYTH, а также хэшем данных (dataHash).
Поддерживает роли для управления доступом.
Предоставляет базовые функции для работы с резервами и накоплением MYTH.
Роли:
DEFAULT_ADMIN_ROLE: Администратор (назначен создателю контракта).
MANAGER: Менеджер (назначен создателю контракта).
Ключевые функции:
initialize: Устанавливает токены и хэш данных при создании.
meritBoost: Позволяет владельцам TotemToken получать MYTH в определенный период (реализация отсутствует).
collectMYTH: Сбор накопленных MYTH из MeritManager (реализация отсутствует).
getReserves: Возвращает баланс TotemToken и MYTH на контракте.
getDataHash: Возвращает хэш данных, связанный с Totem.
Ограничения:
Функции meritBoost и collectMYTH пока не реализованы.
Логика взаимодействия с новыми токенами ограничена до полной продажи токенов (указание в комментарии).
Контракт служит основой для управления резервами и интеграции с системой заслуг, но требует доработки для полной функциональности (например, реализации meritBoost и collectMYTH). Предназначен для хранения активов и предоставления информации о состоянии Totem.

TotemFactory
Назначение: Создание новых экземпляров Totem и их токенов (TotemToken), а также регистрация Totem с уже существующими токенами.
Основные характеристики:
Создает Totem с новым токеном (createTotem) или использует существующий токен (createTotemWithExistingToken).
Использует BeaconProxy для развертывания Totem с заданными параметрами (адрес токена, mythAddr, хэш данных).
Хранит информацию о каждом Totem (создатель, адрес токена, адрес Totem, хэш данных, флаг кастомного токена).
Роли:
DEFAULT_ADMIN_ROLE: Администратор (назначен создателю контракта).
MANAGER: Менеджер, управляющий белым списком токенов.
WHITELISTED: Роль для токенов, разрешенных для использования в createTotemWithExistingToken.
Процесс:
createTotem: Разворачивает новый TotemToken, создает прокси для Totem и регистрирует его в TotemTokenDistributor.
createTotemWithExistingToken: Создает Totem с уже существующим токеном из белого списка (без создания нового токена).
Оба метода требуют оплаты комиссии в ASTR (реализация не завершена).
Ключевые функции:
createTotem: Создание Totem с новым токеном (имя, символ, хэш данных).
createTotemWithExistingToken: Создание Totem с существующим токеном из белого списка.
addTokenToWhitelist / removeTokenFromWhitelist: Управление белым списком токенов (доступно менеджеру).
Ограничения:
Для использования существующих токенов они должны быть в белом списке.
Создание Totem связано с TotemTokenDistributor для дальнейшего распределения токенов.
Контракт предназначен для гибкого развертывания новых Totem с уникальными токенами или интеграции существующих токенов, с учетом контроля доступа и будущей интеграции с системой заслуг (merit system). Некоторые функции (например, оплата в ASTR) требуют доработки.

- TotemToken
Назначение: Создает токен с ограничениями на переводы во время "периода продаж" (sale period) и управлением ролями.
Основные характеристики:
Изначально выпускается 1 миллиард токенов, которые передаются дистрибьютору (totemDistributor).
Во время периода продаж (salePeriod = true) токены могут передаваться только от дистрибьютора и только на адреса из списка разрешенных получателей (allowedRecipients).
После завершения периода продаж (функция openTransfers) ограничения снимаются, и токены становятся свободно передаваемыми.
Роли:
DEFAULT_ADMIN_ROLE: Администратор (назначен создателю контракта).
MANAGER: Менеджер, который может добавлять/удалять адреса из списка разрешенных получателей.
totemDistributor: Дистрибьютор, который управляет токенами в период продаж и может открыть свободные трансферы.
Ограничения:
Трансферы во время периода продаж блокируются, если получатель не в списке allowedRecipients и отправитель не дистрибьютор.
Только дистрибьютор может завершить период продаж.
Функции:
addAllowedRecipient / removeAllowedRecipient: Управление списком разрешенных получателей (доступно менеджеру).
openTransfers: Завершение периода продаж (доступно дистрибьютору).
isAllowedRecipient: Проверка статуса адреса в списке разрешенных.
Контракт подходит для сценариев контролируемого распределения токенов, например, при первичной продаже (ICO), с последующим переходом к свободному обращению.

TotemTokenDistributor
Назначение: Управление продажей токенов Totem в периоде продаж (sale period) и их дальнейшим обращением, включая распределение доходов и добавление ликвидности.
Основные характеристики:
Пользователи могут покупать (buy) и продавать (sell) токены Totem за определенные платежные токены в периоде продаж.
После завершения периода продаж токены становятся свободно передаваемыми, а собранные платежные токены распределяются между пулом доходов, создателем, хранилищем и ликвидностью.
Ограничение на максимальное количество токенов на адрес (maxTokensPerAddress = 5M).
Цена одного Totem в USD фиксирована (oneTotemPriceInUsd = 0.00004 ether).
Роли:
DEFAULT_ADMIN_ROLE: Администратор (назначен создателю контракта).
MANAGER: Менеджер, управляющий настройками (например, адрес платежного токена, фабрика).
Процесс:
Регистрация Totem через TotemFactory: 250K токенов создателю, 100M токенов в контракт Totem.
Покупка: пользователь платит платежными токенами, получает Totem (с учетом лимитов).
Продажа: пользователь возвращает Totem, получает часть платежных токенов обратно.
Завершение периода продаж: токены распределяются (2.5% — пул доходов, 0.5% — создатель, 68.43% — хранилище, 28.57% — ликвидность в AMM).
Ключевые функции:
buy: Покупка токенов в периоде продаж.
sell: Продажа токенов в периоде продаж.
register: Регистрация нового Totem через фабрику.
_closeSalePeriod: Завершение периода продаж и распределение токенов.
Ограничения:
Покупка/продажа доступны только в периоде продаж.
Пользователь не может превысить лимит токенов на адрес.
Поддерживаются только стандартные токены (не кастомные).
Контракт предназначен для контролируемой продажи токенов с последующим переходом к децентрализованному обращению и интеграцией с AMM (автоматизированный маркет-мейкер) для ликвидности. Некоторые функции (например, работа с оракулами и нативными токенами) требуют доработки.

если будешь писать код, комментарии должны быть на английский языке в формате NatSpec
используй только кастомные ошибки

это мои контракты моего протокола:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AccessControlUpgradeable} from "@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol";
import {ReentrancyGuardUpgradeable} from "@openzeppelin-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {VestingWallet} from "@openzeppelin/contracts/finance/VestingWallet.sol";

/**
 * @title MeritManager
 * @dev Manages merit points for registered totems and distributes MYTHO tokens based on merit.
 * Includes features like totem registration, merit crediting, boosting, and claiming rewards.
 */
contract MeritManager is AccessControlUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20 for IERC20;

    // Roles
    bytes32 public constant MANAGER = keccak256("MANAGER");
    bytes32 public constant REGISTRATOR = keccak256("REGISTRATOR");
    bytes32 public constant BLACKLISTED = keccak256("BLACKLISTED");

    // State variables
    address public mythoToken;
    address public revenuePoolAddr;
    address[4] public vestingWallets;
    uint256[4] public vestingWalletsAllocation;
    uint256 public boostFee; // Fee in native tokens for boosting
    uint256 public periodDuration;
    uint256 public deploymentTimestamp;
    uint256 public oneTotemBoost; // Amount of merit points awarded for a boost
    uint256 public mythumMultiplier; // Multiplier for merit during Mythum period (default: 150 = 1.5x)

    mapping(uint256 period => uint256 totalPoints) public totalMeritPoints; // Total merit points across all totems per period
    mapping(uint256 period => mapping(address totemAddress => uint256 points))
        public totemMerit; // Total merit points across all totems per period
    mapping(uint256 period => bool isClaimed) public isClaimed; // Whether rewards have been claimed for a period
    mapping(uint256 period => uint256 releasedMytho) public releasedMytho; // Total MYTHO released per period

    // Period tracking
    uint256 public lastProcessedPeriod; // Last period that was fully processed

    // Array to track all registered totems
    address[] public registeredTotemsList;

    // Boost tracking
    mapping(uint256 => mapping(address => bool)) public userBoostedInPeriod; // Whether a user has boosted in a period
    mapping(uint256 => mapping(address => address)) public userBoostedTotem; // Which Totem a user boosted in a period

    // Totem state tracking
    mapping(address => bool) public registeredTotems;

    // Events
    event TotemRegistered(address indexed totem);
    event TotemBlacklisted(address indexed totem, bool blacklisted);
    event MeritCredited(address indexed totem, uint256 amount, uint256 period);
    event TotemBoosted(
        address indexed totem,
        address indexed booster,
        uint256 amount,
        uint256 period
    );
    event MythoClaimed(address indexed totem, uint256 amount, uint256 period);
    event MythoReleased(uint256 amount, uint256 period);
    event ParameterUpdated(string parameterName, uint256 newValue);

    // Custom errors
    error TotemNotRegistered();
    error TotemInBlocklist();
    error TotemAlreadyRegistered();
    error AlreadyBlacklisted(address totem);
    error AlreadyNotInBlacklist(address totem);
    error InsufficientBoostFee();
    error NotInMythumPeriod();
    error AlreadyBoostedInPeriod();
    error AccessControl();
    error NoMythoToClaim();
    error AlreadyClaimed(uint256 period);
    error InvalidPeriod();
    error TransferFailed();
    error InvalidAddress();

    /**
     * @dev Initializes the contract with required parameters
     * @param _mythoToken Address of the MYTHO token
     * @param _vestingWallets Array of vesting wallet addresses
     */
    function initialize(
        address _mythoToken,
        address _revenuePoolAddr,
        address[4] memory _vestingWallets
    ) public initializer {
        __AccessControl_init();
        __ReentrancyGuard_init();

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER, msg.sender);

        mythoToken = _mythoToken;
        vestingWallets = _vestingWallets;
        periodDuration = 30 days;
        deploymentTimestamp = block.timestamp;
        vestingWalletsAllocation = [
            175_000_000 ether,
            125_000_000 ether,
            100_000_000 ether,
            50_000_000 ether
        ];

        oneTotemBoost = 10; // 10 merit points per boost
        mythumMultiplier = 150; // 1.5x multiplier (150/100)
        boostFee = 0.001 ether; // 0.001 native tokens for boost fee
    }

    /**
     * @dev Registers a new totem
     * @param _totemAddr Address of the totem to register
     */
    function register(address _totemAddr) external {
        if (!hasRole(REGISTRATOR, msg.sender)) revert AccessControl();
        if (registeredTotems[_totemAddr]) revert TotemAlreadyRegistered();
        if (_totemAddr == address(0)) revert InvalidAddress();

        registeredTotems[_totemAddr] = true;
        registeredTotemsList.push(_totemAddr);

        emit TotemRegistered(_totemAddr);
    }

    /**
     * @dev Credits merit points to a registered totem
     * @param _totemAddr Address of the totem to credit
     * @param _amount Amount of merit points to credit
     */
    function creditMerit(
        address _totemAddr,
        uint256 _amount
    ) external onlyRole(MANAGER) {
        if (!registeredTotems[_totemAddr]) revert TotemNotRegistered();
        if (hasRole(BLACKLISTED, _totemAddr)) revert TotemInBlocklist();

        uint256 currentPeriod_ = currentPeriod();

        // Apply Mythum multiplier if in Mythum period
        if (isMythum()) {
            _amount = (_amount * mythumMultiplier) / 100;
        }

        // Add merit to the totem
        totemMerit[currentPeriod_][_totemAddr] += _amount;
        totalMeritPoints[currentPeriod_] += _amount;

        emit MeritCredited(_totemAddr, _amount, currentPeriod_);
    }

    /**
     * @dev Allows a user to boost a totem by paying a fee
     * @param _totemAddr Address of the totem to boost
     */
    function boostTotem(address _totemAddr) external payable nonReentrant {
        if (!registeredTotems[_totemAddr]) revert TotemNotRegistered();
        if (hasRole(BLACKLISTED, _totemAddr)) revert TotemInBlocklist();
        if (msg.value < boostFee) revert InsufficientBoostFee();
        if (!isMythum()) revert NotInMythumPeriod();

        uint256 currentPeriod_ = currentPeriod();

        if (userBoostedInPeriod[currentPeriod_][msg.sender])
            revert AlreadyBoostedInPeriod();

        if (msg.value > boostFee) {
            // Refund excess boost fee
            payable(msg.sender).transfer(msg.value - boostFee);
        } else {
            // Transfer boost fee to revenue pool
            payable(revenuePoolAddr).transfer(boostFee);
        }

        // Mark user as having boosted in this period
        userBoostedInPeriod[currentPeriod_][msg.sender] = true;
        userBoostedTotem[currentPeriod_][msg.sender] = _totemAddr;

        // Add merit to the totem
        totemMerit[currentPeriod_][_totemAddr] += oneTotemBoost;
        totalMeritPoints[currentPeriod_] += oneTotemBoost;

        emit TotemBoosted(
            _totemAddr,
            msg.sender,
            oneTotemBoost,
            currentPeriod_
        );
    }

    /**
     * @dev Allows a totem to claim MYTHO tokens for a specific period
     * @param _periodNum Period number to claim for
     */
    function claimMytho(uint256 _periodNum) external nonReentrant {
        address totemAddr = msg.sender;
        if (!registeredTotems[totemAddr]) revert TotemNotRegistered();
        if (hasRole(BLACKLISTED, totemAddr)) revert TotemInBlocklist();
        if (isClaimed[_periodNum]) revert AlreadyClaimed(_periodNum);
        if (_periodNum > currentPeriod()) revert InvalidPeriod();

        _updateState();

        if (
            totemMerit[_periodNum][totemAddr] == 0 ||
            totalMeritPoints[_periodNum] == 0 ||
            releasedMytho[_periodNum] == 0
        ) revert NoMythoToClaim();

        uint256 totalPoints = totalMeritPoints[_periodNum];
        uint256 totemPoints = totemMerit[_periodNum][totemAddr];

        isClaimed[_periodNum] = true;

        uint256 totemShare = (releasedMytho[_periodNum] * totemPoints) /
            totalPoints;

        IERC20(mythoToken).safeTransfer(totemAddr, totemShare);

        emit MythoClaimed(totemAddr, totemShare, _periodNum);
    }

    /**
     * @dev Updates the state of the contract by processing pending periods
     */
    function _updateState() private {
        uint256 yearIdx = _yearIndex();

        // Check if we're still within the valid year range
        if (yearIdx >= 4) {
            return;
        }

        VestingWallet wallet = VestingWallet(payable(vestingWallets[yearIdx]));

        uint256 _currentPeriod = currentPeriod();

        // Only process completed periods, not the current period
        if (_currentPeriod > lastProcessedPeriod + 1) {
            // Process all completed periods up to but not including the current period
            for (
                uint256 period = lastProcessedPeriod + 1;
                period < _currentPeriod;
                period++
            ) {
                releasedMytho[period] = vestingWalletsAllocation[yearIdx] / 12;
                emit MythoReleased(releasedMytho[period], period);
            }

            wallet.release(address(mythoToken));
            lastProcessedPeriod = _currentPeriod - 1; // Set the last processed period to the previous period
        }
    }

    /**
     * @dev Manually triggers state update
     */
    function updateState() external onlyRole(MANAGER) {
        _updateState();
    }

    // VIEW FUNCTIONS

    /**
     * @dev Returns the current period number
     * @return Current period number
     */
    function currentPeriod() public view returns (uint256) {
        if (block.timestamp < deploymentTimestamp) return 0;
        return (block.timestamp - deploymentTimestamp) / periodDuration;
    }

    /**
     * @dev Checks if the current time is within the Mythum period
     * @return Whether current time is in Mythum period
     */
    function isMythum() public view returns (bool) {
        uint256 currentPeriodStart = deploymentTimestamp +
            (currentPeriod() * periodDuration);
        uint256 mythumStart = currentPeriodStart + ((periodDuration * 3) / 4);
        return block.timestamp >= mythumStart;
    }

    /**
     * @dev Returns the year index based on the current period
     * @return Year index (0-3)
     */
    function _yearIndex() private view returns (uint256) {
        return (currentPeriod() / 12) > 3 ? 3 : (currentPeriod() / 12);
    }

    /**
     * @dev Gets the total number of registered totems
     * @return Total number of registered totems
     */
    function getRegisteredTotemsCount() external view returns (uint256) {
        return registeredTotemsList.length;
    }

    /**
     * @dev Gets all registered totems
     * @return Array of registered totem addresses
     */
    function getAllRegisteredTotems() external view returns (address[] memory) {
        return registeredTotemsList;
    }

    /**
     * @dev Gets the pending MYTHO reward for a totem in a specific period
     * @param _totemAddr Address of the totem
     * @param _periodNum Period number to check
     * @return Pending MYTHO reward amount
     */
    function getPendingReward(
        address _totemAddr,
        uint256 _periodNum
    ) external view returns (uint256) {
        if (
            !registeredTotems[_totemAddr] ||
            hasRole(BLACKLISTED, _totemAddr) ||
            isClaimed[_periodNum] ||
            totemMerit[_periodNum][_totemAddr] == 0 ||
            totalMeritPoints[_periodNum] == 0 ||
            releasedMytho[_periodNum] == 0
        ) {
            return 0;
        }

        uint256 totemPoints = totemMerit[_periodNum][_totemAddr];
        uint256 totalPoints = totalMeritPoints[_periodNum];

        return (releasedMytho[_periodNum] * totemPoints) / totalPoints;
    }

    /**
     * @dev Gets the period time bounds
     * @param _periodNum Period number to check
     * @return startTime Period start timestamp
     * @return endTime Period end timestamp
     */
    function getPeriodTimeBounds(
        uint256 _periodNum
    ) external view returns (uint256 startTime, uint256 endTime) {
        startTime = deploymentTimestamp + (_periodNum * periodDuration);
        endTime = startTime + periodDuration;
        return (startTime, endTime);
    }

    /**
     * @dev Gets the time remaining until the next period
     * @return Time in seconds until the next period
     */
    function getTimeUntilNextPeriod() external view returns (uint256) {
        uint256 currentPeriodEnd = deploymentTimestamp +
            ((currentPeriod() + 1) * periodDuration);
        if (block.timestamp >= currentPeriodEnd) {
            return 0;
        }
        return currentPeriodEnd - block.timestamp;
    }

    /**
     * @dev Gets the timestamp when the current Mythum period starts
     * @return Timestamp of the current Mythum period start
     */
    function getCurrentMythumStart() external view returns (uint256) {
        uint256 currentPeriodStart = deploymentTimestamp +
            (currentPeriod() * periodDuration);
        return currentPeriodStart + ((periodDuration * 3) / 4);
    }

    /**
     * @dev Checks if a totem has been registered
     * @param _totemAddr Address to check
     * @return Whether the address is a registered totem
     */
    function isRegisteredTotem(
        address _totemAddr
    ) external view returns (bool) {
        return registeredTotems[_totemAddr];
    }

    /**
     * @dev Checks if a totem is blacklisted
     * @param _totemAddr Address to check
     * @return Whether the totem is blacklisted
     */
    function isBlacklisted(address _totemAddr) external view returns (bool) {
        return hasRole(BLACKLISTED, _totemAddr);
    }

    /**
     * @dev Gets the total merit points for a totem in a specific period
     * @param _totemAddr Address of the totem
     * @param _periodNum Period number to check
     * @return Merit points for the totem in the specified period
     */
    function getTotemMeritPoints(
        address _totemAddr,
        uint256 _periodNum
    ) external view returns (uint256) {
        return totemMerit[_periodNum][_totemAddr];
    }

    /**
     * @dev Gets whether a user has boosted in a specific period
     * @param _user User address to check
     * @param _periodNum Period number to check
     * @return Whether the user has boosted in the specified period
     */
    function hasUserBoostedInPeriod(
        address _user,
        uint256 _periodNum
    ) external view returns (bool) {
        return userBoostedInPeriod[_periodNum][_user];
    }

    /**
     * @dev Gets which totem a user boosted in a specific period
     * @param _user User address to check
     * @param _periodNum Period number to check
     * @return Address of the totem the user boosted
     */
    function getUserBoostedTotem(
        address _user,
        uint256 _periodNum
    ) external view returns (address) {
        return userBoostedTotem[_periodNum][_user];
    }

    // ADMIN FUNCTIONS

    /**
     * @dev Sets the one Totem boost amount
     * @param _oneTotemBoost New boost amount
     */
    function setOneTotemBoost(
        uint256 _oneTotemBoost
    ) external onlyRole(MANAGER) {
        _updateState();
        oneTotemBoost = _oneTotemBoost;
        emit ParameterUpdated("oneTotemBoost", _oneTotemBoost);
    }

    /**
     * @dev Sets the Mythum multiplier (in percentage, e.g., 150 = 1.5x)
     * @param _mythumMultiplier New multiplier value
     */
    function setMythmsMultiplier(
        uint256 _mythumMultiplier
    ) external onlyRole(MANAGER) {
        _updateState();
        mythumMultiplier = _mythumMultiplier;
        emit ParameterUpdated("mythumMultiplier", _mythumMultiplier);
    }

    /**
     * @dev Sets the boost fee in native tokens
     * @param _boostFee New boost fee
     */
    function setBoostFee(uint256 _boostFee) external onlyRole(MANAGER) {
        _updateState();
        boostFee = _boostFee;
        emit ParameterUpdated("boostFee", _boostFee);
    }

    /**
     * @dev Sets the blacklist status for a totem
     * @param _totem Address of the totem
     * @param _blacklisted Whether to blacklist or unblacklist the totem
     */
    function setTotemBlacklisted(
        address _totem,
        bool _blacklisted
    ) external onlyRole(MANAGER) {
        if (!registeredTotems[_totem]) revert TotemNotRegistered();
        if (hasRole(BLACKLISTED, _totem) && _blacklisted)
            revert AlreadyBlacklisted(_totem);
        if (!hasRole(BLACKLISTED, _totem) && !_blacklisted)
            revert AlreadyNotInBlacklist(_totem);

        if (_blacklisted) {
            grantRole(BLACKLISTED, _totem);
        } else {
            revokeRole(BLACKLISTED, _totem);
        }

        emit TotemBlacklisted(_totem, _blacklisted);
    }

    /**
     * @dev Sets the period duration
     * @param _periodDuration New period duration in seconds
     */
    function setPeriodDuration(
        uint256 _periodDuration
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _updateState();
        periodDuration = _periodDuration;
        emit ParameterUpdated("periodDuration", _periodDuration);
    }

    /**
     * @dev Grants the registrator role to an address
     * @param _registrator Address to grant the role to
     */
    function grantRegistratorRole(
        address _registrator
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(REGISTRATOR, _registrator);
    }

    /**
     * @dev Revokes the registrator role from an address
     * @param _registrator Address to revoke the role from
     */
    function revokeRegistratorRole(
        address _registrator
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(REGISTRATOR, _registrator);
    }

    /**
     * @dev Sets a new MYTHO token address
     * @param _newMythoToken New token address
     */
    function setMythoToken(
        address _newMythoToken
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_newMythoToken == address(0)) revert InvalidAddress();
        mythoToken = _newMythoToken;
    }

    /**
     * @dev Updates a vesting wallet address
     * @param _index Index of the wallet to update (0-3)
     * @param _newWallet New wallet address
     */
    function setVestingWallet(
        uint256 _index,
        address _newWallet
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_index >= 4) revert InvalidPeriod();
        if (_newWallet == address(0)) revert InvalidAddress();

        vestingWallets[_index] = _newWallet;
    }

    /**
     * @dev Updates a vesting wallet allocation
     * @param _index Index of the allocation to update (0-3)
     * @param _newAllocation New allocation amount
     */
    function setVestingWalletAllocation(
        uint256 _index,
        uint256 _newAllocation
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_index >= 4) revert InvalidPeriod();

        vestingWalletsAllocation[_index] = _newAllocation;
    }

    /**
     * @dev Force update of released MYTHO for a specific period
     * @param _periodNum Period number to update
     * @param _amount Amount of MYTHO released
     */
    function forceUpdateReleasedMytho(
        uint256 _periodNum,
        uint256 _amount
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        releasedMytho[_periodNum] = _amount;
        emit MythoReleased(_amount, _periodNum);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {VestingWallet} from "@openzeppelin/contracts/finance/VestingWallet.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title MYTHO Government Token
 * @notice Non-upgradeable ERC20 token with fixed supply and vesting distribution
 */
contract MYTHO is ERC20 {
    using SafeERC20 for ERC20;

    // Custom errors
    error ZeroAddressNotAllowed(string receiverType);
    error OnlyOwnerCanBurn();

    // Token distribution constants
    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 10**18; // 1 billion tokens with 18 decimals
    
    // Totem incentives distribution (50% of total supply)
    uint256 public constant MERIT_YEAR_1 = 175_000_000 * 10**18; // 35% of incentives
    uint256 public constant MERIT_YEAR_2 = 125_000_000 * 10**18; // 25% of incentives
    uint256 public constant MERIT_YEAR_3 = 100_000_000 * 10**18; // 20% of incentives
    uint256 public constant MERIT_YEAR_4 = 50_000_000 * 10**18;  // 10% of incentives
    
    // Team allocation (20% of total supply)
    uint256 public constant TEAM_ALLOCATION = 200_000_000 * 10**18;
    
    // Treasury allocation (18% of total supply)
    uint256 public constant TREASURY_ALLOCATION = 180_000_000 * 10**18;
    
    // Mytho AMM incentives (7% of total supply)
    uint256 public constant AMM_INCENTIVES = 70_000_000 * 10**18;
    
    // Airdrop allocation (5% of total supply)
    uint256 public constant AIRDROP_ALLOCATION = 50_000_000 * 10**18;

    // Vesting duration constants
    uint64 public constant ONE_YEAR = 12 * 30 days;
    uint64 public constant TWO_YEARS = 2 * ONE_YEAR;
    uint64 public constant FOUR_YEARS = 4 * ONE_YEAR;

    // Vesting wallet and recipient addresses (immutable)
    address public immutable meritVestingYear1;
    address public immutable meritVestingYear2;
    address public immutable meritVestingYear3;
    address public immutable meritVestingYear4;
    address public immutable teamVesting;
    address public immutable ammVesting;
    address public immutable treasury;
    address public immutable airdrop;

    /**
     * @notice Constructor to deploy the token and set up vesting schedules
     * @param _meritManager Address to receive totem incentives
     * @param _teamReceiver Address to receive team allocation
     * @param _treasuryReceiver Address to receive treasury allocation
     * @param _ammReceiver Address to receive AMM incentives
     * @param _airdropReceiver Address to receive airdrop allocation
     */
    constructor(
        address _meritManager,
        address _teamReceiver,
        address _treasuryReceiver,
        address _ammReceiver,
        address _airdropReceiver
    ) ERC20("MYTHO Government Token", "MYTHO") {
        if (_meritManager == address(0)) revert ZeroAddressNotAllowed("totem receiver");
        if (_teamReceiver == address(0)) revert ZeroAddressNotAllowed("team receiver");
        if (_treasuryReceiver == address(0)) revert ZeroAddressNotAllowed("treasury receiver");
        if (_ammReceiver == address(0)) revert ZeroAddressNotAllowed("AMM receiver");
        if (_airdropReceiver == address(0)) revert ZeroAddressNotAllowed("airdrop receiver");

        // Set the start timestamp for vesting
        uint64 startTimestamp = uint64(block.timestamp);
        
        // Create vesting wallets for totem incentives (4 years with annual releases)
        meritVestingYear1 = address(new VestingWallet(_meritManager, startTimestamp, ONE_YEAR));
        meritVestingYear2 = address(new VestingWallet(_meritManager, startTimestamp + ONE_YEAR, ONE_YEAR));
        meritVestingYear3 = address(new VestingWallet(_meritManager, startTimestamp + 2 * ONE_YEAR, ONE_YEAR));
        meritVestingYear4 = address(new VestingWallet(_meritManager, startTimestamp + 3 * ONE_YEAR, ONE_YEAR));
        
        // Create vesting wallet for team (2 years)
        teamVesting = address(new VestingWallet(_teamReceiver, startTimestamp, TWO_YEARS));
        
        // Create vesting wallet for AMM incentives (2 years)
        ammVesting = address(new VestingWallet(_ammReceiver, startTimestamp, TWO_YEARS));
        
        // Treasury (no vesting, immediate access)
        treasury = _treasuryReceiver;
        
        // Airdrop (no vesting, immediate access)
        airdrop = _airdropReceiver;

        // Mint the total supply of tokens
        _mint(address(this), TOTAL_SUPPLY);
        
        // Distribute tokens to vesting wallets and addresses
        _transfer(address(this), meritVestingYear1, MERIT_YEAR_1);
        _transfer(address(this), meritVestingYear2, MERIT_YEAR_2);
        _transfer(address(this), meritVestingYear3, MERIT_YEAR_3);
        _transfer(address(this), meritVestingYear4, MERIT_YEAR_4);
        _transfer(address(this), teamVesting, TEAM_ALLOCATION);
        _transfer(address(this), ammVesting, AMM_INCENTIVES);
        _transfer(address(this), treasury, TREASURY_ALLOCATION);
        _transfer(address(this), airdrop, AIRDROP_ALLOCATION);
    }

    /**
     * @notice Burns tokens from the caller's address
     * @dev Can only be called by the token owner
     * @param _account Address from which tokens are burned
     * @param _amount Amount of tokens to burn
     */
    function burn(address _account, uint256 _amount) external {
        if (msg.sender != _account) revert OnlyOwnerCanBurn();
        _burn(_account, _amount);
    }

    /// TEST LOGIC

    function mint(address _account, uint256 _amount) external {
        _mint(_account, _amount);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AccessControlUpgradeable} from "@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title RevenuePool
 * @dev This contract manages and withdraws ERC20 and native tokens.
 * It provides functionality to:
 * - Withdraw ERC20 tokens to specified addresses
 * - Withdraw native tokens to specified addresses
 * - Check balances of ERC20 and native tokens
 */
contract RevenuePool is AccessControlUpgradeable {
    bytes32 private constant MANAGER = keccak256("MANAGER");

    event ERC20Withdrawn(address indexed token, address indexed to, uint256 amount);
    event NativeWithdrawn(address indexed to, uint256 amount);

    error ZeroAddress();
    error ZeroAmount();
    error InsufficientBalance(uint256 requested, uint256 available);

    function initialize() public initializer {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER, msg.sender);
    }

    /**
     * @dev Withdraws ERC20 tokens, restricted to MANAGER
     * @param _token Address of the ERC20 token to withdraw
     * @param _to Recipient address
     * @param _amount Amount of tokens to withdraw
     */
    function withdrawERC20(address _token, address _to, uint256 _amount) external onlyRole(MANAGER) {
        if (_token == address(0) || _to == address(0)) revert ZeroAddress();
        if (_amount == 0) revert ZeroAmount();
        uint256 balance = IERC20(_token).balanceOf(address(this));
        if (balance < _amount) revert InsufficientBalance(_amount, balance);
        IERC20(_token).transfer(_to, _amount);
        emit ERC20Withdrawn(_token, _to, _amount);
    }

    /**
     * @dev Withdraws native tokens, restricted to MANAGER
     * @param _to Recipient address (payable)
     * @param _amount Amount of native tokens to withdraw (in wei)
     */
    function withdrawNative(address payable _to, uint256 _amount) external onlyRole(MANAGER) {
        if (_to == address(0)) revert ZeroAddress();
        if (_amount == 0) revert ZeroAmount();
        if (address(this).balance < _amount) revert InsufficientBalance(_amount, address(this).balance);
        (bool success, ) = _to.call{value: _amount}("");
        require(success, "Native transfer failed");
        emit NativeWithdrawn(_to, _amount);
    }

    /**
     * @dev Allows contract to receive native tokens
     */
    receive() external payable {}

    /// READERS

    /**
     * @dev Returns balance of a specific ERC20 token
     * @param _token Address of the ERC20 token
     * @return Token balance of the contract
     */
    function getERC20Balance(address _token) external view returns (uint256) {
        return IERC20(_token).balanceOf(address(this));
    }

    /**
     * @dev Returns native token balance
     * @return Native token balance of the contract (in wei)
     */
    function getNativeBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AccessControlUpgradeable} from "@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {TotemTokenDistributor} from "./TotemTokenDistributor.sol";
import {MeritManager} from "./MeritManager.sol";
import {AddressRegistry} from "./AddressRegistry.sol";

/**
 * @title Totem
 * @notice This contract represents a Totem in the MYTHO ecosystem, managing token burning and merit distribution
 * @dev Handles the lifecycle of a Totem, including token burning after sale period and merit distribution
 */
contract Totem is AccessControlUpgradeable {
    using SafeERC20 for IERC20;

    IERC20 private totemToken;
    IERC20 private paymentToken;
    IERC20 private liquidityToken;
    IERC20 private mythoToken;

    bytes private dataHash;

    address private treasuryAddr;
    address private totemDistributorAddr;
    address private meritManagerAddr;

    bool private isCustomToken;
    bool public salePeriodEnded;

    bytes32 private constant MANAGER = keccak256("MANAGER");
    bytes32 private constant TOTEM_DISTRIBUTOR = keccak256("TOTEM_DISTRIBUTOR");

    // Events
    event TotemTokenBurned(
        address indexed user,
        uint256 totemTokenAmount,
        uint256 paymentAmount,
        uint256 mythoAmount,
        uint256 lpAmount
    );
    event SalePeriodEnded();
    event MythoCollected(address indexed user, uint256 periodNum);

    // Custom errors
    error SalePeriodNotEnded();
    error InsufficientTotemBalance();
    error InsufficientPaymentTokenBalance();
    error ZeroAmount();

    /**
     * @notice Initializes the Totem contract with token addresses, data hash, and revenue pool
     * @dev Sets up the initial state and grants roles
     * @param _totemToken The address of the TotemToken or custom token
     * @param _dataHash The data hash associated with this Totem
     * @param _registryAddr Address of the AddressRegistry contract
     * @param _isCustomToken Flag indicating if the token is custom (not burnable)
     */
    function initialize(
        IERC20 _totemToken,
        bytes memory _dataHash,
        address _registryAddr,
        bool _isCustomToken
    ) public initializer {
        __AccessControl_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER, msg.sender);

        totemToken = _totemToken;
        dataHash = _dataHash;
        treasuryAddr = AddressRegistry(_registryAddr).getMythoTreasury();
        totemDistributorAddr = AddressRegistry(_registryAddr).getTotemTokenDistributor();
        meritManagerAddr = AddressRegistry(_registryAddr).getMeritManager();
        mythoToken = IERC20(MeritManager(meritManagerAddr).mythoToken());
        isCustomToken = _isCustomToken;
        salePeriodEnded = false; // Initially, sale period is active

        _grantRole(TOTEM_DISTRIBUTOR, totemDistributorAddr);
    }

    /**
     * @notice Allows TotemToken holders to burn or transfer their tokens and receive proportional shares of assets
     * @dev After the sale period ends, burns TotemTokens for standard tokens or transfers custom tokens to treasuryAddr.
     *      User receives proportional shares of payment tokens, MYTHO tokens, and LP tokens.
     * @param _totemTokenAmount The amount of TotemToken to burn or transfer
     */
    function burnTotemTokens(uint256 _totemTokenAmount) external {
        if (!salePeriodEnded) revert SalePeriodNotEnded();
        if (totemToken.balanceOf(msg.sender) < _totemTokenAmount)
            revert InsufficientTotemBalance();
        if (_totemTokenAmount == 0) revert ZeroAmount();

        // Get the total supply of TotemToken
        uint256 totalSupply = totemToken.totalSupply();

        // Calculate the user's share of payment tokens based on their submitted amount
        uint256 paymentTokenBalance = paymentToken.balanceOf(address(this));
        uint256 paymentAmount = (paymentTokenBalance * _totemTokenAmount) /
            totalSupply;

        // Verify payment token balance if needed
        if (paymentAmount == 0) revert InsufficientPaymentTokenBalance();

        // Take TotemTokens from the caller
        totemToken.safeTransferFrom(msg.sender, address(this), _totemTokenAmount);

        // Handle token disposal based on whether it's a custom token
        if (isCustomToken) {
            // For custom tokens, transfer to treasuryAddr instead of burning
            totemToken.safeTransfer(treasuryAddr, _totemTokenAmount);
        } else {
            // For standard TotemTokens, burn them
            TotemTokenDistributor(totemDistributorAddr).burnTotemTokens(
                address(this),
                _totemTokenAmount
            );
        }

        // Transfer the proportional payment tokens to the caller if there are any
        paymentToken.safeTransfer(msg.sender, paymentAmount);
        
        // Calculate and distribute MYTHO tokens
        uint256 mythoBalance = mythoToken.balanceOf(address(this));
        uint256 mythoAmount;
        
        if (mythoBalance > 0) {
            mythoAmount = (mythoBalance * _totemTokenAmount) / totalSupply;
            if (mythoAmount > 0) {
                mythoToken.safeTransfer(msg.sender, mythoAmount);
            }
        }
        
        // Calculate and distribute LP tokens
        uint256 lpAmount;
        if (address(liquidityToken) != address(0)) {
            uint256 lpBalance = liquidityToken.balanceOf(address(this));
            if (lpBalance > 0) {
                lpAmount = (lpBalance * _totemTokenAmount) / totalSupply;
                if (lpAmount > 0) {
                    liquidityToken.safeTransfer(msg.sender, lpAmount);
                }
            }
        }

        emit TotemTokenBurned(msg.sender, _totemTokenAmount, paymentAmount, mythoAmount, lpAmount);
    }

    /**
     * @notice Collects accumulated MYTHO from MeritManager for a specific period
     * @param _periodNum The period number to collect rewards for
     */
    function collectMYTH(uint256 _periodNum) public {
        MeritManager(meritManagerAddr).claimMytho(_periodNum);
        emit MythoCollected(msg.sender, _periodNum);
    }

    /**
     * @notice Sets the payment token and liquidity token addresses and ends the sale period
     * @dev Should be called by TotemTokenDistributor after sale period ends
     * @param _paymentToken The address of the payment token contract
     * @param _liquidityToken The address of the liquidity token (LP token)
     */
    function closeSalePeriod(
        IERC20 _paymentToken,
        IERC20 _liquidityToken
    ) external onlyRole(TOTEM_DISTRIBUTOR) {
        paymentToken = _paymentToken;
        liquidityToken = _liquidityToken;
        salePeriodEnded = true;

        emit SalePeriodEnded();
    }

    /**
     * @notice Get the data hash associated with this Totem
     * @dev Returns the data hash that was set during initialization
     * @return The data hash stored in the contract
     */
    function getDataHash() external view returns (bytes memory) {
        return dataHash;
    }

    /**
     * @notice Get the addresses of tokens associated with this Totem
     * @return totemTokenAddr The address of the Totem token
     * @return paymentTokenAddr The address of the payment token
     * @return liquidityTokenAddr The address of the liquidity token
     */
    function getTokenAddresses() external view returns (
        address totemTokenAddr,
        address paymentTokenAddr,
        address liquidityTokenAddr
    ) {
        return (
            address(totemToken),
            address(paymentToken),
            address(liquidityToken)
        );
    }

    /**
     * @notice Get all token balances of this Totem
     * @return totemBalance The balance of Totem tokens
     * @return paymentBalance The balance of payment tokens
     * @return liquidityBalance The balance of liquidity tokens
     * @return mythoBalance The balance of MYTHO tokens
     */
    function getAllBalances() external view returns (
        uint256 totemBalance,
        uint256 paymentBalance,
        uint256 liquidityBalance,
        uint256 mythoBalance
    ) {
        totemBalance = totemToken.balanceOf(address(this));
        paymentBalance = address(paymentToken) != address(0) ? paymentToken.balanceOf(address(this)) : 0;
        liquidityBalance = address(liquidityToken) != address(0) ? liquidityToken.balanceOf(address(this)) : 0;
        
        address mythoAddr = MeritManager(meritManagerAddr).mythoToken();
        mythoBalance = mythoAddr != address(0) ? IERC20(mythoAddr).balanceOf(address(this)) : 0;
        
        return (totemBalance, paymentBalance, liquidityBalance, mythoBalance);
    }

    /**
     * @notice Check if this is a custom token Totem
     * @return True if this is a custom token Totem, false otherwise
     */
    function isCustomTokenTotem() external view returns (bool) {
        return isCustomToken;
    }
}


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AccessControlUpgradeable} from "@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol";
import {BeaconProxy} from "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {TotemTokenDistributor} from "./TotemTokenDistributor.sol";
import {Totem} from "./Totem.sol";
import {TotemToken} from "./TotemToken.sol";
import {MeritManager} from "./MeritManager.sol";

contract TotemFactory is AccessControlUpgradeable {
    // Totem token distributor instance
    TotemTokenDistributor private totemDistributor;

    // Core contract addresses
    address private beaconAddr;
    address private revenuePoolAddr;
    address private meritManagerAddr;
    
    // ASTR token address
    address private astrTokenAddr;
    
    // Fee settings
    uint256 private creationFee;

    uint256 private lastId;

    mapping(uint256 totemId => TotemData data) private totemData;

    struct TotemData {
        address creator;
        address tokenAddr;
        address totemAddr;
        bytes dataHash;
        bool isCustomToken;
    }

    bytes32 private constant MANAGER = keccak256("MANAGER");
    bytes32 private constant WHITELISTED = keccak256("WHITELISTED");

    event TotemCreated(address totemAddr, address totemTokenAddr, uint256 totemId);
    event TotemWithExistingTokenCreated(
        address totemAddr,
        address totemTokenAddr,
        uint256 totemId
    );
    event CreationFeeUpdated(uint256 oldFee, uint256 newFee);

    error AlreadyWhitelisted(address tokenAddr);
    error NotWhitelisted(address tokenAddr);
    error InsufficientFee(uint256 provided, uint256 required);
    error FeeTransferFailed();
    error ZeroAddress();

    function initialize(
        TotemTokenDistributor _totemDistributor,
        address _beaconAddr,
        address _revenuePoolAddr,
        address _meritManagerAddr,
        address _astrTokenAddr
    ) public initializer {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER, msg.sender);

        // Initialize fee settings
        if (_astrTokenAddr == address(0)) revert ZeroAddress();
        if (_revenuePoolAddr == address(0)) revert ZeroAddress();

        totemDistributor = _totemDistributor;
        beaconAddr = _beaconAddr;
        revenuePoolAddr = _revenuePoolAddr;
        meritManagerAddr = _meritManagerAddr;
        
        astrTokenAddr = _astrTokenAddr;
        creationFee = 1 ether;
    }

    /**
     * @dev Collects creation fee from the sender
     * @param _sender The address paying the fee
     */
    function _collectFee(address _sender) private {
        // Skip fee collection if fee is set to zero
        if (creationFee == 0) return;
        
        // Transfer tokens from sender to fee collector
        bool success = IERC20(astrTokenAddr).transferFrom(_sender, revenuePoolAddr, creationFee);
        if (!success) revert FeeTransferFailed();
    }

    /**
     * @dev Creates a new totem with a new token
     * @param _dataHash The hash of the totem data
     * @param _tokenName The name of the token
     * @param _tokenSymbol The symbol of the token
     */
    function createTotem(
        bytes memory _dataHash,
        string memory _tokenName,
        string memory _tokenSymbol
    ) public {
        // Collect fee in ASTR tokens
        _collectFee(msg.sender);

        TotemToken totemToken = new TotemToken(
            _tokenName,
            _tokenSymbol,
            address(totemDistributor)
        );

        BeaconProxy proxy = new BeaconProxy(
            beaconAddr,
            abi.encodeWithSignature(
                "initialize(address,bytes,address,address,bool,address)",
                address(totemToken),
                _dataHash,
                address(totemDistributor),
                revenuePoolAddr,
                false,
                meritManagerAddr
            )
        );

        totemData[lastId++] = TotemData({
            creator: msg.sender,
            tokenAddr: address(totemToken),
            totemAddr: address(proxy),
            dataHash: _dataHash,
            isCustomToken: false
        });

        // register the totem and make initial tokens distribution
        totemDistributor.register();

        emit TotemCreated(address(proxy), address(totemToken), lastId - 1);
    }

    /**
     * @dev Creates a new totem with an existing whitelisted token
     * @param _dataHash The hash of the totem data
     * @param _tokenAddr The address of the existing token
     */
    function createTotemWithExistingToken(
        bytes memory _dataHash,
        address _tokenAddr
    ) public {
        // Collect fee in ASTR tokens
        _collectFee(msg.sender);

        if (!hasRole(WHITELISTED, _tokenAddr))
            revert NotWhitelisted(_tokenAddr);

        BeaconProxy proxy = new BeaconProxy(
            beaconAddr,
            abi.encodeWithSignature(
                "initialize(address,bytes,address,address,bool,address)",
                _tokenAddr,
                _dataHash,
                address(totemDistributor),
                revenuePoolAddr,
                true,
                meritManagerAddr
            )
        );

        totemData[lastId++] = TotemData({
            creator: msg.sender,
            tokenAddr: _tokenAddr,
            totemAddr: address(proxy),
            dataHash: _dataHash,
            isCustomToken: true
        });

        MeritManager(meritManagerAddr).register(address(proxy)); 

        emit TotemWithExistingTokenCreated(address(proxy), _tokenAddr, lastId - 1);
    }

    /**
     * @dev Updates the creation fee
     * @param _newFee The new fee amount
     */
    function setCreationFee(uint256 _newFee) public onlyRole(MANAGER) {
        uint256 oldFee = creationFee;
        creationFee = _newFee;
        emit CreationFeeUpdated(oldFee, _newFee);
    }

    /**
     * @dev Adds a token to the whitelist
     * @param _token The token address to whitelist
     */
    function addTokenToWhitelist(address _token) public onlyRole(MANAGER) {
        if (hasRole(WHITELISTED, _token)) revert AlreadyWhitelisted(_token);
        grantRole(WHITELISTED, _token);
    }

    /**
     * @dev Removes a token from the whitelist
     * @param _token The token address to remove from whitelist
     */
    function removeTokenFromWhitelist(address _token) public onlyRole(MANAGER) {
        if (!hasRole(WHITELISTED, _token)) revert NotWhitelisted(_token);
        revokeRole(WHITELISTED, _token);
    }

    /// READERS

    /**
     * @dev Gets the current creation fee
     * @return The current fee amount in ASTR tokens
     */
    function getCreationFee() external view returns (uint256) {
        return creationFee;
    }

    /**
     * @dev Gets the last assigned totem ID
     * @return The last totem ID
     */
    function getLastId() external view returns (uint256) {
        return lastId;
    }

    /**
     * @dev Gets data for a specific totem
     * @param _totemId The ID of the totem
     * @return The totem data structure
     */
    function getTotemData(
        uint256 _totemId
    ) external view returns (TotemData memory) {
        return totemData[_totemId];
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title TotemToken
 * @notice ERC20 token with sale period restrictions and role-based access control
 * @dev Extends ERC20 and AccessControl to manage token distribution and transfers
 */
contract TotemToken is ERC20, AccessControl {
    // Indicates if the token is in the sale period (transfers restricted)
    bool private salePeriod;

    // Mapping of addresses allowed to receive tokens during the sale period
    mapping(address => bool) private allowedRecipients;

    // Roles
    bytes32 private constant MANAGER = keccak256("MANAGER");
    bytes32 private constant TOTEM_DISTRIBUTOR = keccak256("TOTEM_DISTRIBUTOR");

    // Custom errors
    error NotAllowedInSalePeriod();    
    error OnlyForDistributor();

    /**
     * @dev Mints 1_000_000_000 tokens and assigns roles; 100% goes to the distributor initially
     * @param name The name of the token
     * @param symbol The symbol of the token
     * @param _totemDistributorAddr The address of the totem distributor
     */
    constructor(
        string memory name, 
        string memory symbol,
        address _totemDistributorAddr
    ) ERC20(name, symbol) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER, msg.sender);
        _grantRole(TOTEM_DISTRIBUTOR, _totemDistributorAddr);

        _mint(_totemDistributorAddr, 1_000_000_000 ether);
        
        salePeriod = true;
    }

    /**
     * @notice Opens token transfers, ending the sale period
     * @dev Can only be called by the totem distributor
     */
    function openTransfers() external onlyRole(TOTEM_DISTRIBUTOR) {
        salePeriod = false;
    }

    function burn(address _who, uint256 _amount) external onlyRole(TOTEM_DISTRIBUTOR) {
        _burn(_who, _amount);
    }

    /**
     * @notice Adds an address to the list of allowed recipients during sale period
     * @dev Restricted to the MANAGER role
     * @param _recipient The address to be allowed as a recipient
     */
    function addAllowedRecipient(address _recipient) external onlyRole(MANAGER) {
        allowedRecipients[_recipient] = true;
    }

    /**
     * @notice Removes an address from the list of allowed recipients during sale period
     * @dev Restricted to the MANAGER role
     * @param _recipient The address to be removed from allowed recipients
     */
    function removeAllowedRecipient(address _recipient) external onlyRole(MANAGER) {
        allowedRecipients[_recipient] = false;
    }

    /**
     * @notice Checks if an address is an allowed recipient during the sale period
     * @param _addr The address to check
     * @return bool True if the address is an allowed recipient, false otherwise
     */
    function isAllowedRecipient(address _addr) public view returns (bool) {
        return allowedRecipients[_addr];
    }

    /// INTERNAL LOGIC

    /**
     * @notice Updates token balances with transfer restrictions during sale period
     * @dev Overrides ERC20 _update to enforce sale period rules
     * @param from The address sending the tokens
     * @param to The address receiving the tokens
     * @param value The amount of tokens being transferred
     */
    function _update(address from, address to, uint256 value) internal override {
        if (salePeriod && !hasRole(TOTEM_DISTRIBUTOR, msg.sender)) revert NotAllowedInSalePeriod();
        super._update(from, to, value);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AccessControlUpgradeable} from "@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol";
import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {TotemFactory} from "./TotemFactory.sol";
import {TotemToken} from "./TotemToken.sol";
import {Totem} from "./Totem.sol";
import {MeritManager} from "./MeritManager.sol";

// Uniswap V2 interfaces
interface IUniswapV2Router02 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    
    function factory() external view returns (address);
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

// Chainlink price feed interface
interface AggregatorV3Interface {
    function decimals() external view returns (uint8);
    function description() external view returns (string memory);
    function version() external view returns (uint256);
    function getRoundData(uint80 _roundId) external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

/**
 * @title TotemTokenDistributor
 * @dev This contract manages the distribution of Totem tokens during and after sales periods.
 * It handles:
 * - Registration of new totems from the TotemFactory
 * - Buying and selling totems during the sales period
 * - Distribution of collected payment tokens after the sales period ends
 * - Adding liquidity to AMM pools
 * - Burning totem tokens
 */

contract TotemTokenDistributor is AccessControlUpgradeable {
    using EnumerableSet for EnumerableSet.AddressSet;

    TotemFactory private factory;
    MeritManager private meritManager;
    IERC20 private mytho;

    uint256 private maxTokensPerAddress;
    uint256 private oneTotemPriceInUsd;

    // contract address for revenue in payment tokens
    address private revenuePool;

    // address of payment token
    address private paymentTokenAddr;
    
    // Uniswap V2 router address
    address private uniswapV2RouterAddr;
    
    // Mapping from token address to Chainlink price feed address
    mapping(address => address) private priceFeedAddresses;

    /// @dev General info about totems
    mapping(address totemTokenAddr => TotemData TotemData) private totems;

    /// @dev Number of sale positions are eq to the used paymentTokens by address
    mapping(address userAddress => mapping(address totemTokenAddr => SalePosInToken))
        private salePositions;

    bytes32 private constant MANAGER = keccak256("MANAGER");

    uint256 private constant POOL_INITIAL_SUPPLY = 200_000_000 ether;
    uint256 private constant REVENUE_PAYMENT_TOKEN_SHARE = 250; // 2.5%
    uint256 private constant TOTEM_CREATOR_PAYMENT_TOKEN_SHARE = 50; // 0.5%
    uint256 private constant POOL_PAYMENT_TOKEN_SHARE = 2857; // 28.57%
    uint256 private constant VAULT_PAYMENT_TOKEN_SHARE = 6843; // 68.43%
    uint256 private constant PRECISION = 10000;

    struct TotemData {
        address totemAddr;
        address creator;
        address paymentToken;
        bool registered;
        bool isSalePeriod;
        uint256 collectedPaymentTokens;
    }

    struct SalePosInToken {
        // Payment tokens which spent on totems
        uint256 paymentTokenAmount;
        // Totem tokens which bought for payment tokens
        uint256 totemTokenAmount;
    }

    // Events
    event TotemTokensBought(
        address buyer,
        address paymentTokenAddr,
        address totemTokenAddr,
        uint256 totemTokenAmount
    );
    event TotemTokensSold(
        address buyer,
        address paymentTokenAddr,
        address totemTokenAddr,
        uint256 totemTokenAmount
    );
    event TotemRegistered(
        address totemAddr,
        address creator,
        address totemTokenAddr
    );

    // Custom errors
    error AlreadyRegistered(address totemTokenAddr);
    error NotAllowedForCustomTokens();
    error UnknownTotemToken(address tokenAddr);
    error WrongAmount(uint256 tokenAmount);
    error NotPaymentToken(address tokenAddr);
    error OnlyInSalePeriod();
    error NotAllowedInSalePeriod();
    error WrongPaymentTokenAmount(uint256 paymentTokenAmount);
    error OnlyForTotem();

    function initialize(
        IERC20 _mytho,
        MeritManager _meritManager,
        address _revenuePool
    ) public initializer {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER, msg.sender);

        mytho = _mytho;
        meritManager = _meritManager;
        revenuePool = _revenuePool;

        maxTokensPerAddress = 5_000_000 ether;
        oneTotemPriceInUsd = 0.00004 ether;
    }

    modifier whenSalePeriod(address _totemTokenAddr) {
        if (!totems[_totemTokenAddr].isSalePeriod) revert OnlyInSalePeriod();
        _;
    }

    /// @notice Being called by TotemFactory during totem creation
    function register() external {
        // get info about the totem being created
        TotemFactory.TotemData memory totemDataFromFactory = factory
            .getTotemData(factory.getLastId() - 1);

        if (totemDataFromFactory.isCustomToken)
            revert NotAllowedForCustomTokens();
        if (totems[totemDataFromFactory.tokenAddr].registered)
            revert AlreadyRegistered(totemDataFromFactory.tokenAddr);

        totems[totemDataFromFactory.tokenAddr] = TotemData(
            totemDataFromFactory.totemAddr,
            totemDataFromFactory.creator,
            paymentTokenAddr,
            true,
            true,
            0
        );

        TotemToken token = TotemToken(totemDataFromFactory.tokenAddr);
        token.transfer(totemDataFromFactory.creator, 250_000 ether);
        token.transfer(totemDataFromFactory.totemAddr, 100_000_000 ether);

        emit TotemRegistered(
            totemDataFromFactory.totemAddr,
            totemDataFromFactory.creator,
            totemDataFromFactory.tokenAddr
        );
    }

    /// @notice Buy totems for allowed payment tokens
    function buy(
        address _totemTokenAddr,
        uint256 _totemTokenAmount
    ) external whenSalePeriod(_totemTokenAddr) {
        if (!totems[_totemTokenAddr].registered)
            revert UnknownTotemToken(_totemTokenAddr);
        if (
            // check if contract has enough totem tokens + initial pool supply
            IERC20(_totemTokenAddr).balanceOf(address(this)) <
            _totemTokenAmount + POOL_INITIAL_SUPPLY ||
            // check if user has no more than maxTokensPerAddress
            IERC20(_totemTokenAddr).balanceOf(msg.sender) + _totemTokenAmount >
            maxTokensPerAddress
        ) revert WrongAmount(_totemTokenAmount);

        uint256 paymentTokenAmount = _totemsToPaymentToken(
            paymentTokenAddr,
            _totemTokenAmount
        );

        // check if user has enough payment tokens
        if (IERC20(paymentTokenAddr).balanceOf(msg.sender) < paymentTokenAmount)
            revert WrongPaymentTokenAmount(paymentTokenAmount);

        // update totems payment token amount
        totems[_totemTokenAddr].collectedPaymentTokens += paymentTokenAmount;

        // update user sale position
        SalePosInToken storage position = salePositions[msg.sender][
            _totemTokenAddr
        ];
        position.paymentTokenAmount += paymentTokenAmount;
        position.totemTokenAmount += _totemTokenAmount;

        IERC20(paymentTokenAddr).transferFrom(
            msg.sender,
            address(this),
            paymentTokenAmount
        );
        IERC20(_totemTokenAddr).transfer(msg.sender, _totemTokenAmount);

        emit TotemTokensBought(
            msg.sender,
            paymentTokenAddr,
            _totemTokenAddr,
            _totemTokenAmount
        );
    }

    /// @notice Sell totems for used payment token in sale period
    function sell(
        address _totemTokenAddr,
        uint256 _totemTokenAmount
    ) external whenSalePeriod(_totemTokenAddr) {
        SalePosInToken storage position = salePositions[msg.sender][
            _totemTokenAddr
        ];
        address _paymentTokenAddr = totems[_totemTokenAddr].paymentToken;

        // check if balances are correct
        if (
            _totemTokenAmount > position.totemTokenAmount ||
            _totemTokenAmount > IERC20(_totemTokenAddr).balanceOf(msg.sender) ||
            _totemTokenAmount == 0
        ) revert WrongAmount(_totemTokenAmount);

        // calculate the right number of payment tokens according to _totemTokenAmount share in sale position
        /// @custom:check for correct calculation
        uint256 paymentTokensBack = (position.paymentTokenAmount *
            _totemTokenAmount) / position.totemTokenAmount;

        // update totems payment token amount
        totems[_totemTokenAddr].collectedPaymentTokens -= paymentTokensBack;

        // update user sale position
        position.totemTokenAmount -= _totemTokenAmount;
        position.paymentTokenAmount -= paymentTokensBack;

        // send payment tokens and take totem tokens
        IERC20(_totemTokenAddr).transferFrom(
            msg.sender,
            address(this),
            _totemTokenAmount
        );
        IERC20(_paymentTokenAddr).transfer(msg.sender, paymentTokensBack);

        // when all tokens are sold sale period is closed
        if (IERC20(_totemTokenAddr).balanceOf(address(this)) == 0) {
            _closeSalePeriod(_totemTokenAddr);
        }

        emit TotemTokensSold(
            msg.sender,
            _paymentTokenAddr,
            _totemTokenAddr,
            _totemTokenAmount
        );
    }
    
    function burnTotemTokens(
        address _totemTokenAddr,
        uint256 _totemTokenAmount
    ) external {
        if (msg.sender != totems[_totemTokenAddr].totemAddr)
            revert OnlyForTotem();
        TotemToken(_totemTokenAddr).burn(msg.sender, _totemTokenAmount);
    }

    /// INTERNAL LOGIC

    function _closeSalePeriod(address _totemTokenAddr) internal {
        // close sale period and open burn functionality for totem token
        totems[_totemTokenAddr].isSalePeriod = false;

        // open transfers for totem token
        TotemToken(_totemTokenAddr).openTransfers();

        // register totem in MeritManager and activate merit distribution for it
        meritManager.register(totems[_totemTokenAddr].totemAddr);

        // distrubute collected payment tokens
        uint256 paymentTokenAmount = totems[_totemTokenAddr]
            .collectedPaymentTokens;
        address _paymentTokenAddr = totems[_totemTokenAddr].paymentToken;

        // set payment token for Totem and close sale period
        Totem(totems[_totemTokenAddr].totemAddr).setPaymentTokenAndEndSale(IERC20(_paymentTokenAddr));

        // calculate revenue share
        uint256 revenueShare = (paymentTokenAmount * REVENUE_PAYMENT_TOKEN_SHARE) / PRECISION;
        IERC20(_paymentTokenAddr).transfer(revenuePool, revenueShare);

        // calculate totem creator share
        uint256 creatorShare = (paymentTokenAmount * TOTEM_CREATOR_PAYMENT_TOKEN_SHARE) /
            PRECISION;
        IERC20(_paymentTokenAddr).transfer(
            totems[_totemTokenAddr].creator,
            creatorShare
        );

        // calculate totem vault share
        uint256 vaultShare = (paymentTokenAmount * VAULT_PAYMENT_TOKEN_SHARE) /
            PRECISION;
        IERC20(_paymentTokenAddr).transfer(
            totems[_totemTokenAddr].totemAddr,
            vaultShare
        );

        // calculate totem pool share
        uint256 poolShare = (paymentTokenAmount * POOL_PAYMENT_TOKEN_SHARE) /
            PRECISION;

        // send liquidity to AMM and relay LP tokens to Totem
        (uint256 liquidity, address liquidityToken) = _addLiquidity(
            _totemTokenAddr,
            _paymentTokenAddr,
            POOL_INITIAL_SUPPLY,
            poolShare
        );
        IERC20(liquidityToken).transfer(
            totems[_totemTokenAddr].totemAddr,
            liquidity
        );
    }

    /**
     * @notice Adds liquidity to a Uniswap V2 pool
     * @dev Approves tokens for the router and adds liquidity to the pool
     * @param _totemTokenAddr Address of the totem token
     * @param _paymentTokenAddr Address of the payment token
     * @param _totemTokenAmount Amount of totem tokens to add to the pool
     * @param _paymentTokenAmount Amount of payment tokens to add to the pool
     * @return liquidity Amount of liquidity tokens received
     * @return liquidityToken Address of the liquidity token (pair)
     */
    function _addLiquidity(
        address _totemTokenAddr,
        address _paymentTokenAddr,
        uint256 _totemTokenAmount,
        uint256 _paymentTokenAmount
    )
        internal
        returns (uint256 liquidity, address liquidityToken)
    {
        if (uniswapV2RouterAddr == address(0)) revert("Uniswap router not set");
        
        IUniswapV2Router02 router = IUniswapV2Router02(uniswapV2RouterAddr);
        
        // Get the factory address
        address factoryAddr = router.factory();
        IUniswapV2Factory factory_ = IUniswapV2Factory(factoryAddr);
        
        // Get or create the pair
        liquidityToken = factory_.getPair(_totemTokenAddr, _paymentTokenAddr);
        if (liquidityToken == address(0)) {
            liquidityToken = factory_.createPair(_totemTokenAddr, _paymentTokenAddr);
        }
        
        // Approve tokens for the router
        IERC20(_totemTokenAddr).approve(uniswapV2RouterAddr, _totemTokenAmount);
        IERC20(_paymentTokenAddr).approve(uniswapV2RouterAddr, _paymentTokenAmount);
        
        // Add liquidity
        (,, liquidity) = router.addLiquidity(
            _totemTokenAddr,
            _paymentTokenAddr,
            _totemTokenAmount,
            _paymentTokenAmount,
            0, // Accept any amount of token A
            0, // Accept any amount of token B
            address(this), // Send LP tokens to this contract
            block.timestamp + 600 // Deadline: 10 minutes from now
        );
        
        return (liquidity, liquidityToken);
    }

    /// ADMIN LOGIC

    function setPaymentToken(
        address _paymentTokenAddr
    ) external onlyRole(MANAGER) {
        paymentTokenAddr = _paymentTokenAddr;
    }

    function setTotemFactory(TotemFactory _factory) external onlyRole(MANAGER) {
        factory = _factory;
    }

    function setMaxTotemTokensPerAddress(
        uint256 _amount
    ) external onlyRole(MANAGER) {
        maxTokensPerAddress = _amount;
    }
    
    /**
     * @notice Sets the Uniswap V2 router address
     * @param _routerAddr Address of the Uniswap V2 router
     */
    function setUniswapV2Router(address _routerAddr) external onlyRole(MANAGER) {
        uniswapV2RouterAddr = _routerAddr;
    }
    
    /**
     * @notice Sets the price feed address for a token
     * @param _tokenAddr Address of the token
     * @param _priceFeedAddr Address of the Chainlink price feed for the token/USD pair
     */
    function setPriceFeed(address _tokenAddr, address _priceFeedAddr) external onlyRole(MANAGER) {
        priceFeedAddresses[_tokenAddr] = _priceFeedAddr;
    }

    /// READERS

    function _totemsToPaymentToken(
        address _tokenAddr,
        uint256 _totemsAmount
    ) public view returns (uint256) {
        return (_totemsAmount * oneTotemPriceInUsd) / getPrice(_tokenAddr);
    }

    function _paymentTokenToTotems(
        address _tokenAddr,
        uint256 _paymentTokenAmount
    ) public view returns (uint256) {
        return
            (_paymentTokenAmount * getPrice(_tokenAddr)) / oneTotemPriceInUsd;
    }

    /**
     * @notice Returns the price of a given token in USD
     * @dev Uses Chainlink price feeds to get the token price in USD
     * @param _tokenAddr Address of the token to get the price for
     * @return Amount of tokens equivalent to 1 USD
     */
    function getPrice(address _tokenAddr) public view returns (uint256) {
        address priceFeedAddr = priceFeedAddresses[_tokenAddr];
        
        if (priceFeedAddr == address(0)) {
            // If no price feed is set for this token, return a default value
            return 0.05 * 1e18;
        }
        
        // Get the latest price from Chainlink
        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceFeedAddr);
        (
            ,
            int256 price,
            ,
            ,
            
        ) = priceFeed.latestRoundData();
        
        if (price <= 0) {
            // If price is invalid, return a default value
            return 0.05 * 1e18;
        }
        
        // Get the number of decimals in the price feed
        uint8 decimals = priceFeed.decimals();
        
        // Calculate how many tokens are equivalent to 1 USD
        // Price from Chainlink is in USD per token with 'decimals' decimal places
        // We want tokens per USD with 18 decimal places
        
        // First, normalize the price to 18 decimals
        uint256 normalizedPrice;
        if (decimals < 18) {
            normalizedPrice = uint256(price) * (10 ** (18 - decimals));
        } else {
            normalizedPrice = uint256(price) / (10 ** (decimals - 18));
        }
        
        // Then calculate tokens per USD: 1e36 / price
        // 1e36 = 1 USD (with 18 decimals) * 1e18 (for division precision)
        return (1e36) / normalizedPrice;
    }

    function getPaymentToken() external view returns (address) {
        return paymentTokenAddr;
    }

    function getPosition(
        address _addr,
        address _totemTokenAddr
    ) external view returns (SalePosInToken memory) {
        return salePositions[_addr][_totemTokenAddr];
    }
}